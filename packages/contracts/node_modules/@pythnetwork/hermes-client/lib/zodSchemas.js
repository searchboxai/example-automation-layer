"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.api = exports.schemas = void 0;
exports.createApiClient = createApiClient;
const core_1 = require("@zodios/core");
const zod_1 = require("zod");
const AssetType = zod_1.z.enum([
    "crypto",
    "fx",
    "equity",
    "metal",
    "rates",
    "crypto_redemption_rate",
]);
const asset_type = AssetType.nullish();
const RpcPriceIdentifier = zod_1.z.string();
const PriceFeedMetadata = zod_1.z
    .object({ attributes: zod_1.z.record(zod_1.z.string()), id: RpcPriceIdentifier })
    .passthrough();
const PriceIdInput = zod_1.z.string();
const EncodingType = zod_1.z.enum(["hex", "base64"]);
const BinaryUpdate = zod_1.z
    .object({ data: zod_1.z.array(zod_1.z.string()), encoding: EncodingType })
    .passthrough();
const RpcPrice = zod_1.z
    .object({
    conf: zod_1.z.string(),
    expo: zod_1.z.number().int(),
    price: zod_1.z.string(),
    publish_time: zod_1.z.number().int(),
})
    .passthrough();
const RpcPriceFeedMetadataV2 = zod_1.z
    .object({
    prev_publish_time: zod_1.z.number().int().nullable(),
    proof_available_time: zod_1.z.number().int().nullable(),
    slot: zod_1.z.number().int().gte(0).nullable(),
})
    .partial()
    .passthrough();
const ParsedPriceUpdate = zod_1.z
    .object({
    ema_price: RpcPrice,
    id: RpcPriceIdentifier,
    metadata: RpcPriceFeedMetadataV2,
    price: RpcPrice,
})
    .passthrough();
const PriceUpdate = zod_1.z
    .object({
    binary: BinaryUpdate,
    parsed: zod_1.z.array(ParsedPriceUpdate).nullish(),
})
    .passthrough();
const ParsedPublisherStakeCap = zod_1.z
    .object({ cap: zod_1.z.number().int().gte(0), publisher: zod_1.z.string() })
    .passthrough();
const ParsedPublisherStakeCapsUpdate = zod_1.z
    .object({ publisher_stake_caps: zod_1.z.array(ParsedPublisherStakeCap) })
    .passthrough();
const LatestPublisherStakeCapsUpdateDataResponse = zod_1.z
    .object({
    binary: BinaryUpdate,
    parsed: zod_1.z.array(ParsedPublisherStakeCapsUpdate).nullish(),
})
    .passthrough();
const ParsedPriceFeedTwap = zod_1.z
    .object({
    down_slots_ratio: zod_1.z.string(),
    end_timestamp: zod_1.z.number().int(),
    id: RpcPriceIdentifier,
    start_timestamp: zod_1.z.number().int(),
    twap: RpcPrice,
})
    .passthrough();
const TwapsResponse = zod_1.z
    .object({
    binary: BinaryUpdate,
    parsed: zod_1.z.array(ParsedPriceFeedTwap).nullish(),
})
    .passthrough();
exports.schemas = {
    AssetType,
    asset_type,
    RpcPriceIdentifier,
    PriceFeedMetadata,
    PriceIdInput,
    EncodingType,
    BinaryUpdate,
    RpcPrice,
    RpcPriceFeedMetadataV2,
    ParsedPriceUpdate,
    PriceUpdate,
    ParsedPublisherStakeCap,
    ParsedPublisherStakeCapsUpdate,
    LatestPublisherStakeCapsUpdateDataResponse,
    ParsedPriceFeedTwap,
    TwapsResponse,
};
const endpoints = (0, core_1.makeApi)([
    {
        method: "get",
        path: "/v2/price_feeds",
        alias: "price_feeds_metadata",
        description: `Get the set of price feeds.

This endpoint fetches all price feeds from the Pyth network. It can be filtered by asset type
and query string.`,
        requestFormat: "json",
        parameters: [
            {
                name: "query",
                type: "Query",
                schema: zod_1.z.string().nullish(),
            },
            {
                name: "asset_type",
                type: "Query",
                schema: asset_type,
            },
        ],
        response: zod_1.z.array(PriceFeedMetadata),
    },
    {
        method: "get",
        path: "/v2/updates/price/:publish_time",
        alias: "timestamp_price_updates",
        description: `Get the latest price updates by price feed id.

Given a collection of price feed ids, retrieve the latest Pyth price for each price feed.`,
        requestFormat: "json",
        parameters: [
            {
                name: "publish_time",
                type: "Path",
                schema: zod_1.z.number().int(),
            },
            {
                name: "ids[]",
                type: "Query",
                schema: zod_1.z.array(PriceIdInput),
            },
            {
                name: "encoding",
                type: "Query",
                schema: zod_1.z.enum(["hex", "base64"]).optional(),
            },
            {
                name: "parsed",
                type: "Query",
                schema: zod_1.z.boolean().optional(),
            },
            {
                name: "ignore_invalid_price_ids",
                type: "Query",
                schema: zod_1.z.boolean().optional(),
            },
        ],
        response: PriceUpdate,
        errors: [
            {
                status: 404,
                description: `Price ids not found`,
                schema: zod_1.z.void(),
            },
        ],
    },
    {
        method: "get",
        path: "/v2/updates/price/latest",
        alias: "latest_price_updates",
        description: `Get the latest price updates by price feed id.

Given a collection of price feed ids, retrieve the latest Pyth price for each price feed.`,
        requestFormat: "json",
        parameters: [
            {
                name: "ids[]",
                type: "Query",
                schema: zod_1.z.array(PriceIdInput),
            },
            {
                name: "encoding",
                type: "Query",
                schema: zod_1.z.enum(["hex", "base64"]).optional(),
            },
            {
                name: "parsed",
                type: "Query",
                schema: zod_1.z.boolean().optional(),
            },
            {
                name: "ignore_invalid_price_ids",
                type: "Query",
                schema: zod_1.z.boolean().optional(),
            },
        ],
        response: PriceUpdate,
        errors: [
            {
                status: 404,
                description: `Price ids not found`,
                schema: zod_1.z.void(),
            },
        ],
    },
    {
        method: "get",
        path: "/v2/updates/price/stream",
        alias: "price_stream_sse_handler",
        description: `SSE route handler for streaming price updates.`,
        requestFormat: "json",
        parameters: [
            {
                name: "ids[]",
                type: "Query",
                schema: zod_1.z.array(PriceIdInput),
            },
            {
                name: "encoding",
                type: "Query",
                schema: zod_1.z.enum(["hex", "base64"]).optional(),
            },
            {
                name: "parsed",
                type: "Query",
                schema: zod_1.z.boolean().optional(),
            },
            {
                name: "allow_unordered",
                type: "Query",
                schema: zod_1.z.boolean().optional(),
            },
            {
                name: "benchmarks_only",
                type: "Query",
                schema: zod_1.z.boolean().optional(),
            },
            {
                name: "ignore_invalid_price_ids",
                type: "Query",
                schema: zod_1.z.boolean().optional(),
            },
        ],
        response: PriceUpdate,
        errors: [
            {
                status: 404,
                description: `Price ids not found`,
                schema: zod_1.z.void(),
            },
        ],
    },
    {
        method: "get",
        path: "/v2/updates/publisher_stake_caps/latest",
        alias: "latest_publisher_stake_caps",
        description: `Get the most recent publisher stake caps update data.`,
        requestFormat: "json",
        parameters: [
            {
                name: "encoding",
                type: "Query",
                schema: zod_1.z.enum(["hex", "base64"]).optional(),
            },
            {
                name: "parsed",
                type: "Query",
                schema: zod_1.z.boolean().optional(),
            },
        ],
        response: LatestPublisherStakeCapsUpdateDataResponse,
    },
    {
        method: "get",
        path: "/v2/updates/twap/:window_seconds/latest",
        alias: "latest_twaps",
        description: `Get the latest TWAP by price feed id with a custom time window.

Given a collection of price feed ids, retrieve the latest Pyth TWAP price for each price feed.`,
        requestFormat: "json",
        parameters: [
            {
                name: "window_seconds",
                type: "Path",
                schema: zod_1.z.number().int().gte(0),
            },
            {
                name: "ids[]",
                type: "Query",
                schema: zod_1.z.array(PriceIdInput),
            },
            {
                name: "encoding",
                type: "Query",
                schema: zod_1.z.enum(["hex", "base64"]).optional(),
            },
            {
                name: "parsed",
                type: "Query",
                schema: zod_1.z.boolean().optional(),
            },
            {
                name: "ignore_invalid_price_ids",
                type: "Query",
                schema: zod_1.z.boolean().optional(),
            },
        ],
        response: TwapsResponse,
        errors: [
            {
                status: 404,
                description: `Price ids not found`,
                schema: zod_1.z.void(),
            },
        ],
    },
]);
exports.api = new core_1.Zodios(endpoints);
function createApiClient(baseUrl, options) {
    return new core_1.Zodios(baseUrl, endpoints, options);
}
